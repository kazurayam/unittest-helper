= Unit Test Helper

- author: kazurayam
- date: Nov, 2023
- source project: link:https://github.com/kazurayam/unittest-helper[]
- javadoc: link:https://kazurayam.github.io/unittest-helper/api[]

== Problems to solve

=== Is "Current Working Directory" reliable for unit-tests? --- Not always

I encountered some difficulties in a TestNG test case in a Gradle Multi-project. I expected that a call to `System.getProperty("user.dir")` would return the Path of subproject's directory. In most cases, yes. It works fine. But sometimes it failed. See the following post for detail:

- https://github.com/kazurayam/selenium-webdriver-java/issues/22

I couldn't find out the reason why the "current working directory" became the parent project's directory, not the subproject directory.


=== Temporary output files shouldn't be located into the project's directory

The easiest way to locate an output file from a unit-test is to call `java.io.File("some-file.txt")` or `java.nio.Paths("some-file.txt")`. Then the `some-file.txt` will be located under the current working directory = `System.getProperty("user.dir")`. Using Maven and Gradle, the current working directory will usually be equal to the project's directory. By calling `java.io.File(relative path)` often, you will get a lot of temporary files located in the project directory, like this.

[source]
----
.
├── 2023.10.24_22.07.27.742-7440524241d0dbd63ca5eec377b6455c.png    --- x
├── 2023.10.24_22.07.29.333-7440524241d0dbd63ca5eec377b6455c.png    --- x
├── build
│   ├── allure-results
│   ├── classes
│   ├── downloads
│   ├── generated
│   ├── reports
│   ├── resources
│   ├── test-results
│   └── tmp
├── build.gradle
├── extentReport.html    --- x
├── fullpage-screenshot-chrome.png    --- x
├── gradle
│   └── wrapper
├── gradlew
├── gradlew.bat
├── login.har    --- x
├── my-pdf.pdf    --- x
├── pom.xml
├── screenshot.png    --- x
├── src
│   ├── main
│   └── test
├── target
│   ├── classes
│   ├── generated-sources
│   ├── generated-test-sources
│   ├── maven-status
│   └── test-classes
├── testAccessibility.json    --- x
├── webdrivermanager.pdf    --- x
├── webdrivermanager.png    --- x
└── webelement-screenshot.png    --- x

20 directories, 15 files
----
Here the files labeled with "--- x" are the temporary output files created by the unit-tests.

Temporary files located in the project directory make the project tree dirty. The files scattered in the project directory are difficult to manage. If you want to remove them, you have to choose each files and delete them one by one manually.

Rather, I want to create a dedicated directory where all test classes should write their output into. I would list it in the `.gitignore` file to exclude the temporary files out of the git repository.

== Solution

This project provides a Java class link:https://github.com/kazurayam/unittest-helper/blob/develop/lib/src/main/java/com/kazurayam/unittest/TestOutputOrganizer.java[`com.kazurayam.unittest.TestOutputOrganizer`].

The `TestOutputOrganizer` helps your unit tests to save files into a dedicated directory in the Maven/Gradle project. Using this class, you can easily prepare a directory into which your unit tests can write files. The location of the output directory is resolved via the classpath of the unit-test class. The `TestOutputOrganizer` does ot depend on the value returned by `System.getProperty("user.dir")`.

The `TestOutputOrgainzer` class is independent on the type of unit-testing frameworks you choose: JUnit4, JUnit5 and TestNG.

The `TestOutputOrgainzer` class is compiled by Java8.

=== Background

The following post in the Gradle forum gave me a clue:

- link:https://discuss.gradle.org/t/how-do-i-set-the-working-directory-for-testng-in-a-multi-project-gradle-build/7379/7[Gradle Forums, How do I set the working dreictory for TestNG in a multi-project Gradle build?]

____
luke_daley
Gradle Employee
Nov '13

Loading from the filesystem using relative paths during unit tests is problematic because different environments will set a different working directory for the test process. For example, Gradle uses the projects directory while IntelliJ uses the directory of the root project.

The only really safe way to solve this problem is to load via the classpath. Is this a possibility for your scenario?
____


== Description by examples

=== Example 1: Resolving a file path by Current Working Directory

[source,java]
----
include::../app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerAbsentTest.java[]
----
link:https://github.com/kazurayam/unittest-helper/blob/develop/app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerAbsentTest.java[source]

This code calls `Paths.get("sample1_txt")` to resolve the path of output file. Many developers would do the same in their own codes. This code prints the following message:

----
> Task :app:testClasses
[test_write_under_current_working_directory] p = ~/github/unittest-helper/app/sample1.txt
----

The call to `Paths.get("sample1.txt")` regards the parameter `sample1.txt` as relative to the runtime *Current Working Directory*. In the above case, the current working directory WILL be set `~/github/unittest-helper/app/`. And the path is equal to the project directory. So the `Paths.get("sample1.txt")` will return a Path object of `~/github.unittest-helper/app/sample1.txt`.

Is the *current working directory* equal to the *project directory* ? --- Usually yes. But sometimes not. It depends on the runtime environment. When the current working directory is different from the project directory, we will be really confused.

So I do not like my unit-tests to depend on the current working directory. Any other way?

=== Example 2 : resolve the project dir via classpath

[source, java]
----
include::../app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[lines=1..18]
----
link:https://github.com/kazurayam/unittest-helper/blob/develop/app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[source]

`new TestHelper(this.getClass()).getProjectDir()` returns the `java.nio.file.Path` of the project directory.

This test prints the following result in the console:

----
sublistPattern [build, classes, java, test] is found in the code source path [Users, kazurayam, github, unittest-helper, app, build, classes, java, test] at the index 5
[test_getProjectDir] projectDir = ~/github/unittest-helper/app
----

This message tells how `TestHelper.getProject()` internally works.

1. The constructor call `new TestHelper(this.getClass())` tells the `TestHelper` instance that the class was loaded from the directory `/Users/kazurayam/github/unittest-helper/app/build/classes/java/test`.
2. The `TestHelper` internally tries to find out which build tool you used: Maven or Gradle? If you used Maven, the project directory would have a subdirectory `target/test-classes`. So `TestHelper` tries to find `target/test-classes` in the code source path. If the pattern is found, then the parent directory of the `target` directory is presumed to be the project directory. If you used Gradle, the project directory would have a subdirectory `build/classes/java/test`. So `TestHelper` tries to find `build/classes/java/test` in the code source path. When the subdirectory pattern is found in the code source path, then the parent directory of the `build` directory is presumed to be the project dir.

The following patterns are implemented in the `com.kazurayam.unittest.ProjectRepositoryResolver` class:

- `[target, test-classes]`
- `[build, classes, java, test]`
- `[build, classes, groovy, test]`
- `[build, classes, kotlin, test]`

You can add more sublist patterns for your own needs by calling the `TestHelper.addSublistPattern(List<String>)` method.

=== Example 3 : locate the default output directory `test-output`

Quickly find the `test-output` directory by calling `getOutputDir()`.

[source, java]
----
include::../app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[lines=19..24]
----
link:https://github.com/kazurayam/unittest-helper/blob/develop/app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[source]

=== Example 3 : create a custom output directory

[source, java]
----
include::../app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[lines=26..33]
----
link:https://github.com/kazurayam/unittest-helper/blob/develop/app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[source]


=== Example 4 : write a file into the default output directory

[source, java]
----
include::../app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[lines=38..45]
----
link:https://github.com/kazurayam/unittest-helper/blob/develop/app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[source]


=== Example 5 : write a file into a subdirectory under the test-output

[source, java]
----
include::../app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[lines=47..53]
----
link:https://github.com/kazurayam/unittest-helper/blob/develop/app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[source]


=== Example 6 : write a file into a custom output directory

[source, java]
----
include::../app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[lines=58..65]
----
link:https://github.com/kazurayam/unittest-helper/blob/develop/app/src/test/java/com/kazurayam/unittesthelperdemo/OrganizerPresentTest.java[source]

=== Removing the output directory recursively

The `TestOutputOrganizer` class implements `cleanOutputDirectory()` method which removes the output directory recursively. See the following sample test class.

[source, java]
----
include::../app/src/test/java/io/github/someone/somestuff/SampleTest.java[]
----
link:https://github.com/kazurayam/unittest-helper/blob/develop/app/src/test/java/io/github/someone/somestuff/SampleTest.java[source]

The `@BeforeClass`-annotated method is invoked once as soon as this test class started only once. By calling `too.cleanOutputDirectory()`, the `test-output` directory is removed. This method is useful when the test class writes files with timestamp in its name. If you do not clean the dir, you will accumulate a lot of files with different timestamps in the file name. For example:

[source]
----
app/build/tmp/testOutput
└── io.github.someone.somestuff.SampleTest
    └── test_write_file
        ├── sample_20231103_090143.txt
        ├── sample_20231103_094723.txt
        ├── sample_20231103_094759.txt
        ├── sample_20231103_094810.txt
        └── sample_20231103_094817.txt
----

By `cleanOutputDirectory`, you would have a cleaner result, like:

[source]
----
app/build/tmp/testOutput
└── io.github.someone.somestuff.SampleTest
    └── test_write_file
        └── sample_20231103_094817.txt
----

There is `cleanOutputSubDirectory()` method as well. This will choose a specific sub directory specfied by `setSubDir(Path subDir)` method, remove and recreate it. It will leave other subdirectories in the output dir untouched.

=== Translating a Path to a Home Relative string

A Path object can be turned into a string, which is an absolute path string like:

[source]
----
/Users/kazurayam/github/unittest-helper/lib/
----

In this string you can find my personal name `kazurayam`.

However, quite often, I do not like exposing my personal name in the forum posts and in the documentations. I would prefer Home Relative path expression starting with tilde character, like:

[source]
----
~/github/unittest-helper/lib/
----

The `TestOutputOrganizer` class implements a method `String toHomeRelativeString(Path p)`. This method does the translation.

[source, java]
----
include::../lib/src/test/java/com/kazurayam/unittest/TestOutputOrganizerTest.java[lines=95..102]
----

This test prints the following output in the console:

[source]
----
[test_toHomeRelativeString_simple] ~/github/unittest-helper/lib
----

=== You should create a Factory class for your customized TestOutputOrganizer

It is a good practice for you to create a factory class that creates an instance of `TestOutputOrganizer` with customized parameter values. See the following example.

[source]
----
include::../app/src/test/java/io/github/someone/somestuff/TestOutputOrganizerFactory.java[]
----


The `create(Class)` method will instanciate a `com.kazurayam.unittest.TestOutputOrganizer` class with customized parameter values:

1. the output directory will be located at `<projectDir>/build/tmp/testOutput`
2. in the output directory, it will create subdirectory of which name is equal to the Fully Qualified Class Name of the test class.

The following test class uses the Factory.

[source]
----
include::../app/src/test/java/io/github/someone/somestuff/SampleTest.java[lines=1..44]
----

When you ran the test, the output directory will look like this:

[source]
----
app/build/tmp/testOutput
└── io.github.someone.somestuff.SampleTest
    └── test_write_file
        └── sample_20231103_094817.txt
----

Which test class, which method created this file? --- It's obvious to see in this file tree.

Please note that here 2 layers of directories are inserted amongst the output directory `app/build/tmp/testOutput` and the file `sample_yyyyMMdd_HHmmss.txt`. The first layer is the FQCN of the test class, the second layer is the method name which actually wrote the file. This tree helps you well organize the output files created by your test cases.

=== One more layer of subdirectory to distinguish outputs by 2 or more test methods

The link:https://github.com/kazurayam/unittest-helper/blob/develop/app/src/test/java/io/github/someone/somestuff/SampleTest.java[io.github.someone.somestuff.SampleTest] class has one more test method:

[source]
----
include::../app/src/test/java/io/github/someone/somestuff/SampleTest.java[lines=46..57]
----

When you ran this test, you would get the following output:

```
$ tree app/build/tmp/testOutput
app/build/tmp/testOutput
└── io.github.someone.somestuff.SampleTest
    ├── test_write_file
    │   └── sample_20231103_124015.txt
    └── test_write_file_once_more
        └── sample_20231103_124015.txt
```

Please find that one more directory layer is inserted between the output dir and the files.

- `test_write_file`
- `test_write_file_once_more`

How these directories were created? If you read the source of the test class, you would find that it effectively executed the following calls

[source]
----
    Path p = too.resolveOutut("test_write_file/sample_20231103_124015.txt");
----

and

[source]
----
    Path p = too.resolveOutut("test_write_file_once_more/sample_20231103_124015.txt");
----

I am sure you can find a small twist in the above code fragments. It is thus easy to insert layers of directories under the output directory using the `TestOutputOrganizer. This technique makes it easy to organize output files created by multiple methods in a single test class.
